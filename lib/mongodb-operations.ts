// Stub exports for mongodb-operations (do not use on client)
export const getProducts = () => { throw new Error("Server-only: getProducts is not available on client."); };
export const createProduct = () => { throw new Error("Server-only: createProduct is not available on client."); };
export const updateProduct = () => { throw new Error("Server-only: updateProduct is not available on client."); };
export const deleteProduct = () => { throw new Error("Server-only: deleteProduct is not available on client."); };
export const getVendors = () => { throw new Error("Server-only: getVendors is not available on client."); };
export const getOrders = () => { throw new Error("Server-only: getOrders is not available on client."); };
export const getUserCart = () => { throw new Error("Server-only: getUserCart is not available on client."); };
export const updateUserProfileInDb = () => { throw new Error("Server-only: updateUserProfileInDb is not available on client."); };
export const deleteStore = () => { throw new Error("Server-only: deleteStore is not available on client."); };
export const deleteProductsByVendor = () => { throw new Error("Server-only: deleteProductsByVendor is not available on client."); };
export const deleteServicesByVendor = () => { throw new Error("Server-only: deleteServicesByVendor is not available on client."); };
export const deleteOrdersByVendor = () => { throw new Error("Server-only: deleteOrdersByVendor is not available on client."); };
export const deleteBookingsByVendor = () => { throw new Error("Server-only: deleteBookingsByVendor is not available on client."); };
export const deleteUserCartItemsByVendor = () => { throw new Error("Server-only: deleteUserCartItemsByVendor is not available on client."); };
export const deleteConversationsByVendor = () => { throw new Error("Server-only: deleteConversationsByVendor is not available on client."); };
export const deleteUser = () => { throw new Error("Server-only: deleteUser is not available on client."); };
export const deleteSessions = () => { throw new Error("Server-only: deleteSessions is not available on client."); };
// Stub exports for mongodb-operations (do not use on client)
export const getProducts = () => { throw new Error("Server-only: getProducts is not available on client."); };
export const createProduct = () => { throw new Error("Server-only: createProduct is not available on client."); };
export const updateProduct = () => { throw new Error("Server-only: updateProduct is not available on client."); };
export const deleteProduct = () => { throw new Error("Server-only: deleteProduct is not available on client."); };
export const getVendors = () => { throw new Error("Server-only: getVendors is not available on client."); };
export const getOrders = () => { throw new Error("Server-only: getOrders is not available on client."); };
export const getUserCart = () => { throw new Error("Server-only: getUserCart is not available on client."); };
export const updateUserProfileInDb = () => { throw new Error("Server-only: updateUserProfileInDb is not available on client."); };
export const deleteStore = () => { throw new Error("Server-only: deleteStore is not available on client."); };
export const deleteProductsByVendor = () => { throw new Error("Server-only: deleteProductsByVendor is not available on client."); };
export const deleteServicesByVendor = () => { throw new Error("Server-only: deleteServicesByVendor is not available on client."); };
export const deleteOrdersByVendor = () => { throw new Error("Server-only: deleteOrdersByVendor is not available on client."); };
export const deleteBookingsByVendor = () => { throw new Error("Server-only: deleteBookingsByVendor is not available on client."); };
export const deleteUserCartItemsByVendor = () => { throw new Error("Server-only: deleteUserCartItemsByVendor is not available on client."); };
export const deleteConversationsByVendor = () => { throw new Error("Server-only: deleteConversationsByVendor is not available on client."); };
export const deleteUser = () => { throw new Error("Server-only: deleteUser is not available on client."); };
export const deleteSessions = () => { throw new Error("Server-only: deleteSessions is not available on client."); };
// Stub exports for mongodb-operations (do not use on client)
export const getProducts = () => { throw new Error("Server-only: getProducts is not available on client."); };
export const createProduct = () => { throw new Error("Server-only: createProduct is not available on client."); };
export const updateProduct = () => { throw new Error("Server-only: updateProduct is not available on client."); };
export const deleteProduct = () => { throw new Error("Server-only: deleteProduct is not available on client."); };
export const getVendors = () => { throw new Error("Server-only: getVendors is not available on client."); };
export const getOrders = () => { throw new Error("Server-only: getOrders is not available on client."); };
export const getUserCart = () => { throw new Error("Server-only: getUserCart is not available on client."); };
export const updateUserProfileInDb = () => { throw new Error("Server-only: updateUserProfileInDb is not available on client."); };
export const deleteStore = () => { throw new Error("Server-only: deleteStore is not available on client."); };
export const deleteProductsByVendor = () => { throw new Error("Server-only: deleteProductsByVendor is not available on client."); };
export const deleteServicesByVendor = () => { throw new Error("Server-only: deleteServicesByVendor is not available on client."); };
export const deleteOrdersByVendor = () => { throw new Error("Server-only: deleteOrdersByVendor is not available on client."); };
export const deleteBookingsByVendor = () => { throw new Error("Server-only: deleteBookingsByVendor is not available on client."); };
export const deleteUserCartItemsByVendor = () => { throw new Error("Server-only: deleteUserCartItemsByVendor is not available on client."); };
export const deleteConversationsByVendor = () => { throw new Error("Server-only: deleteConversationsByVendor is not available on client."); };
export const deleteUser = () => { throw new Error("Server-only: deleteUser is not available on client."); };
export const deleteSessions = () => { throw new Error("Server-only: deleteSessions is not available on client."); };
// Stub exports for mongodb-operations (do not use on client)
export const getProducts = () => { throw new Error("Server-only: getProducts is not available on client."); };
export const createProduct = () => { throw new Error("Server-only: createProduct is not available on client."); };
export const updateProduct = () => { throw new Error("Server-only: updateProduct is not available on client."); };
export const deleteProduct = () => { throw new Error("Server-only: deleteProduct is not available on client."); };
export const getVendors = () => { throw new Error("Server-only: getVendors is not available on client."); };
export const getOrders = () => { throw new Error("Server-only: getOrders is not available on client."); };
export const getUserCart = () => { throw new Error("Server-only: getUserCart is not available on client."); };
export const updateUserProfileInDb = () => { throw new Error("Server-only: updateUserProfileInDb is not available on client."); };
export const deleteStore = () => { throw new Error("Server-only: deleteStore is not available on client."); };
export const deleteProductsByVendor = () => { throw new Error("Server-only: deleteProductsByVendor is not available on client."); };
export const deleteServicesByVendor = () => { throw new Error("Server-only: deleteServicesByVendor is not available on client."); };
export const deleteOrdersByVendor = () => { throw new Error("Server-only: deleteOrdersByVendor is not available on client."); };
export const deleteBookingsByVendor = () => { throw new Error("Server-only: deleteBookingsByVendor is not available on client."); };
export const deleteUserCartItemsByVendor = () => { throw new Error("Server-only: deleteUserCartItemsByVendor is not available on client."); };
export const deleteConversationsByVendor = () => { throw new Error("Server-only: deleteConversationsByVendor is not available on client."); };
export const deleteUser = () => { throw new Error("Server-only: deleteUser is not available on client."); };
export const deleteSessions = () => { throw new Error("Server-only: deleteSessions is not available on client."); };
// Stub exports for mongodb-operations (do not use on client)
export const getProducts = () => { throw new Error("Server-only: getProducts is not available on client."); };
export const createProduct = () => { throw new Error("Server-only: createProduct is not available on client."); };
export const updateProduct = () => { throw new Error("Server-only: updateProduct is not available on client."); };
export const deleteProduct = () => { throw new Error("Server-only: deleteProduct is not available on client."); };
export const getVendors = () => { throw new Error("Server-only: getVendors is not available on client."); };
export const getOrders = () => { throw new Error("Server-only: getOrders is not available on client."); };
export const getUserCart = () => { throw new Error("Server-only: getUserCart is not available on client."); };
export const updateUserProfileInDb = () => { throw new Error("Server-only: updateUserProfileInDb is not available on client."); };
export const deleteStore = () => { throw new Error("Server-only: deleteStore is not available on client."); };
export const deleteProductsByVendor = () => { throw new Error("Server-only: deleteProductsByVendor is not available on client."); };
export const deleteServicesByVendor = () => { throw new Error("Server-only: deleteServicesByVendor is not available on client."); };
export const deleteOrdersByVendor = () => { throw new Error("Server-only: deleteOrdersByVendor is not available on client."); };
export const deleteBookingsByVendor = () => { throw new Error("Server-only: deleteBookingsByVendor is not available on client."); };
export const deleteUserCartItemsByVendor = () => { throw new Error("Server-only: deleteUserCartItemsByVendor is not available on client."); };
export const deleteConversationsByVendor = () => { throw new Error("Server-only: deleteConversationsByVendor is not available on client."); };
export const deleteUser = () => { throw new Error("Server-only: deleteUser is not available on client."); };
export const deleteSessions = () => { throw new Error("Server-only: deleteSessions is not available on client."); };
// Stub exports for mongodb-operations (do not use on client)
export const getProducts = () => { throw new Error("Server-only: getProducts is not available on client."); };
export const createProduct = () => { throw new Error("Server-only: createProduct is not available on client."); };
export const updateProduct = () => { throw new Error("Server-only: updateProduct is not available on client."); };
export const deleteProduct = () => { throw new Error("Server-only: deleteProduct is not available on client."); };
export const getVendors = () => { throw new Error("Server-only: getVendors is not available on client."); };
export const getOrders = () => { throw new Error("Server-only: getOrders is not available on client."); };
export const getUserCart = () => { throw new Error("Server-only: getUserCart is not available on client."); };
export const updateUserProfileInDb = () => { throw new Error("Server-only: updateUserProfileInDb is not available on client."); };
export const deleteStore = () => { throw new Error("Server-only: deleteStore is not available on client."); };
export const deleteProductsByVendor = () => { throw new Error("Server-only: deleteProductsByVendor is not available on client."); };
export const deleteServicesByVendor = () => { throw new Error("Server-only: deleteServicesByVendor is not available on client."); };
export const deleteOrdersByVendor = () => { throw new Error("Server-only: deleteOrdersByVendor is not available on client."); };
export const deleteBookingsByVendor = () => { throw new Error("Server-only: deleteBookingsByVendor is not available on client."); };
export const deleteUserCartItemsByVendor = () => { throw new Error("Server-only: deleteUserCartItemsByVendor is not available on client."); };
export const deleteConversationsByVendor = () => { throw new Error("Server-only: deleteConversationsByVendor is not available on client."); };
export const deleteUser = () => { throw new Error("Server-only: deleteUser is not available on client."); };
export const deleteSessions = () => { throw new Error("Server-only: deleteSessions is not available on client."); };

export const getProducts = notServerError;
export const createChatMessage = notServerError;
export const getChatMessages = notServerError;
export const getConversations = notServerError;
export const createConversation = notServerError;
  await connectToDatabase()
  
  const query: any = {}
  
  if (filters?.category) {
    query.category = filters.category
  }
  if (filters?.vendorId) {
    query.vendorId = filters.vendorId
  }
  if (filters?.featured !== undefined) {
    query.featured = filters.featured
  }

  let productQuery = Product.find(query).sort({ createdAt: -1 })
  
  if (filters?.limitCount) {
    productQuery = productQuery.limit(filters.limitCount)
  }

  return await productQuery.lean().exec()
}

export const createProduct = async (productData: Omit<IProduct, 'id' | 'createdAt' | 'updatedAt'>) => {
  await connectToDatabase()
  
  const product = new Product({
    ...productData,
    status: productData.stock > 0 ? "active" : "out_of_stock"
  })
  
  const savedProduct = await product.save()
  return savedProduct._id.toString()
}

export const updateProduct = async (productId: string, productData: Partial<IProduct>) => {
  await connectToDatabase()
  
  await Product.findByIdAndUpdate(productId, productData, { new: true })
}

export const deleteProduct = async (productId: string) => {
  await connectToDatabase()
  
  await Product.findByIdAndDelete(productId)
}

export const getVendorProducts = async (vendorId: string) => {
  await connectToDatabase()
  
  return await Product.find({ vendorId })
    .sort({ createdAt: -1 })
    .lean()
    .exec()
}

export const getProductById = async (id: string) => {
  await connectToDatabase()
  
  const product = await Product.findById(id).lean().exec()
  if (!product) {
    throw new Error("Product not found")
  }
  return product
}

// Order operations
export const getOrders = async (filters?: {
  vendorId?: string
  customerId?: string
  status?: string
  limitCount?: number
}) => {
  await connectToDatabase()
  
  const query: any = {}
  
  if (filters?.vendorId) {
    query.vendorId = filters.vendorId
  }
  if (filters?.customerId) {
    query.customerId = filters.customerId
  }
  if (filters?.status) {
    query.status = filters.status
  }

  let orderQuery = Order.find(query).sort({ createdAt: -1 })
  
  if (filters?.limitCount) {
    orderQuery = orderQuery.limit(filters.limitCount)
  }

  return await orderQuery.lean().exec()
}

export const createOrder = async (orderData: Omit<IOrder, 'id' | 'createdAt' | 'updatedAt'>) => {
  await connectToDatabase()

  // Increment sales count for each product in the order
  if (orderData.items && Array.isArray(orderData.items)) {
    for (const item of orderData.items) {
      if (item.productId && item.quantity) {
        await Product.findByIdAndUpdate(
          item.productId,
          { $inc: { sales: item.quantity } },
          { new: true }
        )
      }
    }
  }

  const order = new Order(orderData)
  const savedOrder = await order.save()
  return savedOrder._id.toString()
}

export const getOrderById = async (orderId: string) => {
  await connectToDatabase()
  
  return await Order.findOne({ orderId }).lean().exec()
}

export const updateOrder = async (orderId: string, orderData: Partial<IOrder>) => {
  await connectToDatabase()
  
  await Order.findOneAndUpdate({ orderId }, orderData, { new: true })
}

// Store operations
export const getStores = async (filters?: {
  category?: string
  isOpen?: boolean
  limitCount?: number
  subscriptionStatus?: string
  isActive?: boolean
  vendorId?: string
}) => {
  await connectToDatabase()
  
  const query: any = {}
  
  if (filters?.category && filters.category !== "all") {
    query.category = filters.category
  }
  if (filters?.isOpen !== undefined) {
    query.isOpen = filters.isOpen
  }
  if (filters?.vendorId) {
    query.vendorId = filters.vendorId
  }
  // Handle subscription filtering with backward compatibility
  if (filters?.subscriptionStatus || filters?.isActive !== undefined) {
    if (filters.subscriptionStatus) {
      query.subscriptionStatus = filters.subscriptionStatus
    }
    if (filters.isActive !== undefined) {
      query.isActive = filters.isActive
    }
  } else {
    // By default, exclude only explicitly suspended stores
    // This allows legacy stores (without subscription fields) to show
    query.$and = [
      {
        $or: [
          { accountStatus: { $ne: 'suspended' } },
          { accountStatus: { $exists: false } }
        ]
      },
      {
        $or: [
          { subscriptionStatus: { $ne: 'suspended' } },
          { subscriptionStatus: { $exists: false } }
        ]
      }
    ]
  }

  let storeQuery = Store.find(query)
  
  if (filters?.limitCount) {
    storeQuery = storeQuery.limit(filters.limitCount)
  } else {
    // Sort by creation date for consistent ordering
    storeQuery = storeQuery.sort({ createdAt: -1 })
  }

  return await storeQuery.lean().exec()
}

export const getStoreById = async (storeId: string) => {
  await connectToDatabase()
  
  const store = await Store.findById(storeId).lean().exec()
  if (!store) {
    throw new Error("Store not found")
  }
  return store
}

export const createStore = async (storeData: Omit<IStore, 'id' | 'createdAt' | 'updatedAt'>) => {
  await connectToDatabase()
  
  console.log("Creating store for vendor:", storeData.vendorId)
  
  const store = new Store(storeData)
  const savedStore = await store.save()
  
  console.log("Store created successfully:", savedStore._id)
  return savedStore._id.toString()
}

export const updateStore = async (storeId: string, storeData: Partial<IStore>) => {
  await connectToDatabase()
  // DEBUG: Log update object
  console.log('updateStore called with:', JSON.stringify(storeData, null, 2));
  await Store.findByIdAndUpdate(storeId, storeData, { new: true })
}

// Service operations
export const getServices = async (filters?: {
  category?: string
  providerId?: string
  featured?: boolean
  locationType?: string
  limitCount?: number
}) => {
  await connectToDatabase()
  
  const query: any = {}
  
  if (filters?.category && filters.category !== "all") {
    query.category = filters.category
  }
  if (filters?.providerId) {
    query.providerId = filters.providerId
  }
  if (filters?.featured !== undefined) {
    query.featured = filters.featured
  }
  if (filters?.locationType) {
    query.locationType = filters.locationType
  }

  let serviceQuery = Service.find(query).sort({ createdAt: -1 })
  
  if (filters?.limitCount) {
    serviceQuery = serviceQuery.limit(filters.limitCount)
  }

  const services = await serviceQuery.lean().exec()
  
  // Map _id to id for consistency
  interface LeanService {
    [key: string]: any;
    _id: any;
  }

  interface ServiceWithId extends LeanService {
    id: string;
    _id: string;
  }

  const typedServices: LeanService[] = services;

  return typedServices.map<ServiceWithId>((service: LeanService) => ({
    ...service,
    id: service._id.toString(),
    _id: service._id.toString()
  }));
}

export const createService = async (serviceData: Omit<IService, 'id' | 'createdAt' | 'updatedAt'>) => {
  await connectToDatabase()
  
  const service = new Service(serviceData)
  const savedService = await service.save()
  const serviceObj = savedService.toObject()
  return {
    ...serviceObj,
    id: savedService._id.toString(),
    _id: savedService._id.toString()
  }
}

export const updateService = async (serviceId: string, serviceData: Partial<IService>) => {
  await connectToDatabase()
  
  await Service.findByIdAndUpdate(serviceId, serviceData, { new: true })
}

export const deleteService = async (serviceId: string) => {
  await connectToDatabase()
  
  await Service.findByIdAndDelete(serviceId)
}

export const getServiceById = async (serviceId: string) => {
  await connectToDatabase()
  
  const service = await Service.findById(serviceId).lean().exec()
  if (!service) {
    throw new Error("Service not found")
  }
  return {
    ...service,
    id: service._id.toString(),
    _id: service._id.toString()
  }
}

// Booking operations
export const getBookings = async (filters?: {
  customerId?: string
  providerId?: string
  serviceId?: string
  status?: string
  limitCount?: number
}) => {
  await connectToDatabase()
  
  const query: any = {}
  
  if (filters?.customerId) {
    query.customerId = filters.customerId
  }
  if (filters?.providerId) {
    query.providerId = filters.providerId
  }
  if (filters?.serviceId) {
    query.serviceId = filters.serviceId
  }
  if (filters?.status) {
    query.status = filters.status
  }

  let bookingQuery = Booking.find(query).sort({ createdAt: -1 })
  
  if (filters?.limitCount) {
    bookingQuery = bookingQuery.limit(filters.limitCount)
  }

  return await bookingQuery.lean().exec()
}

export const createBooking = async (bookingData: Omit<IBooking, 'id' | 'createdAt' | 'updatedAt'>) => {
  await connectToDatabase()
  
  const booking = new Booking(bookingData)
  const savedBooking = await booking.save()
  return savedBooking._id.toString()
}

export const updateBooking = async (bookingId: string, bookingData: Partial<IBooking>) => {
  await connectToDatabase()
  
  await Booking.findByIdAndUpdate(bookingId, bookingData, { new: true })
}

// Support Ticket operations
export const createSupportTicket = async (ticketData: Omit<ISupportTicket, 'id' | 'createdAt' | 'updatedAt'>) => {
  await connectToDatabase()
  
  const ticket = new SupportTicket(ticketData)
  const savedTicket = await ticket.save()
  return savedTicket._id.toString()
}

export const getSupportTickets = async (filters?: {
  customerId?: string
  vendorId?: string
  status?: string
  limitCount?: number
}) => {
  await connectToDatabase()
  
  const query: any = {}
  
  if (filters?.customerId) {
    query.customerId = filters.customerId
  }
  if (filters?.vendorId) {
    query.vendorId = filters.vendorId
  }
  if (filters?.status) {
    query.status = filters.status
  }

  let ticketQuery = SupportTicket.find(query).sort({ createdAt: -1 })
  
  if (filters?.limitCount) {
    ticketQuery = ticketQuery.limit(filters.limitCount)
  }

  return await ticketQuery.lean().exec()
}

export const updateSupportTicket = async (ticketId: string, ticketData: Partial<ISupportTicket>) => {
  await connectToDatabase()
  
  await SupportTicket.findByIdAndUpdate(ticketId, ticketData, { new: true })
}

// Notification operations
export const createNotification = async (notificationData: Omit<INotification, 'id' | 'createdAt'>) => {
  await connectToDatabase()
  
  const notification = new Notification(notificationData)
  const savedNotification = await notification.save()
  return savedNotification._id.toString()
}

export const getNotifications = async (userId: string, limitCount?: number) => {
  await connectToDatabase()
  
  let notificationQuery = Notification.find({ userId }).sort({ createdAt: -1 })
  
  if (limitCount) {
    notificationQuery = notificationQuery.limit(limitCount)
  }

  return await notificationQuery.lean().exec()
}

export const markNotificationAsRead = async (notificationId: string) => {
  await connectToDatabase()
  
  await Notification.findByIdAndUpdate(notificationId, { read: true }, { new: true })
}

// User Cart operations
export const getUserCart = async (userId: string) => {
  await connectToDatabase()
  
  const cart = await UserCart.findOne({ userId }).lean().exec()
  return cart
}

export const setUserCart = async (userId: string, items: any[]) => {
  await connectToDatabase()
  
  await UserCart.findOneAndUpdate(
    { userId },
    { items, updatedAt: new Date() },
    { upsert: true, new: true }
  )
}

// Conversation operations
export { getConversations, createConversation } from './conversations-operations'

// Chat Message operations
// ...Chat Message feature removed for rebuild...

// Generic CRUD operations
export const createDocument = async (collectionName: string, data: any) => {
  await connectToDatabase()
  
  // Map collection names to models
  const modelMap: Record<string, any> = {
    'products': Product,
    'orders': Order,
    'stores': Store,
    'services': Service,
    'bookings': Booking,
    'support_tickets': SupportTicket,
    'notifications': Notification,
    'user_carts': UserCart
  }

  const Model = modelMap[collectionName]
  if (!Model) {
    throw new Error(`Unknown collection: ${collectionName}`)
  }

  const doc = new Model(data)
  const savedDoc = await doc.save()
  return savedDoc._id.toString()
}

export const getDocument = async (collectionName: string, docId: string) => {
  await connectToDatabase()
  
  const modelMap: Record<string, any> = {
    'products': Product,
    'orders': Order,
    'stores': Store,
    'services': Service,
    'bookings': Booking,
    'support_tickets': SupportTicket,
    'notifications': Notification,
    'user_carts': UserCart
  }

  const Model = modelMap[collectionName]
  if (!Model) {
    throw new Error(`Unknown collection: ${collectionName}`)
  }

  const doc = await Model.findById(docId).lean().exec()
  return doc ? { id: doc._id, ...doc } : null
}

export const updateDocument = async (collectionName: string, docId: string, data: any) => {
  await connectToDatabase()
  
  const modelMap: Record<string, any> = {
    'products': Product,
    'orders': Order,
    'stores': Store,
    'services': Service,
    'bookings': Booking,
    'support_tickets': SupportTicket,
    'notifications': Notification,
    'user_carts': UserCart
  }

  const Model = modelMap[collectionName]
  if (!Model) {
    throw new Error(`Unknown collection: ${collectionName}`)
  }

  await Model.findByIdAndUpdate(docId, data, { new: true })
}

export const deleteDocument = async (collectionName: string, docId: string) => {
  await connectToDatabase()
  
  const modelMap: Record<string, any> = {
    'products': Product,
    'orders': Order,
    'stores': Store,
    'services': Service,
    'bookings': Booking,
    'support_tickets': SupportTicket,
    'notifications': Notification,
    'user_carts': UserCart
  }

  const Model = modelMap[collectionName]
  if (!Model) {
    throw new Error(`Unknown collection: ${collectionName}`)
  }

  await Model.findByIdAndDelete(docId)
}

// Export types for backward compatibility
export type {
  IProduct as Product,
  IOrder as Order,
  IStore as Store,
  IService as Service,
  IBooking as Booking,
  ISupportTicket as SupportTicket,
  INotification as Notification,
  IUserCart as UserCart
}

// Vendor-specific helper functions
export const getOrdersByVendor = async (vendorId: string) => {
    await connectToDatabase();
    // Find orders where vendorId matches top-level OR is present in vendors array
    const orders = await Order.find({
      $or: [
        { vendorId },
        { 'vendors.vendorId': vendorId }
      ]
    }).lean().exec();
    return orders;
}

export const getAllOrders = async () => {
  return await getOrders()
}

export const getBookingsByProvider = async (providerId: string) => {
  return await getBookings({ providerId })
}

export const getAllBookings = async () => {
  return await getBookings()
}

// User operations
export const getUserById = async (userId: string) => {
  await connectToDatabase()
  return await User.findById(userId).lean().exec()
}

export const getUsersByRole = async (role: string) => {
  await connectToDatabase()
  return await User.find({ role }).lean().exec()
}

// Update user profile (name/email)
export const updateUserProfileInDb = async (uid: string, updates: { displayName?: string; email?: string }) => {
  await connectToDatabase();
  const update: any = {};
  if (updates.displayName) update.name = updates.displayName;
  if (updates.email) update.email = updates.email;
  const result = await User.findByIdAndUpdate(uid, update, { new: true });
  return result;
};

// Comprehensive deletion functions for account closure
export const deleteStore = async (vendorId: string) => {
  await connectToDatabase()
  await Store.findOneAndDelete({ vendorId })
}

export const deleteProductsByVendor = async (vendorId: string) => {
  await connectToDatabase()
  await Product.deleteMany({ vendorId })
}

export const deleteServicesByVendor = async (vendorId: string) => {
  await connectToDatabase()
  await Service.deleteMany({ providerId: vendorId })
}

export const deleteOrdersByVendor = async (vendorId: string) => {
  await connectToDatabase()
  // Mark orders as cancelled rather than deleting for record-keeping
  await Order.updateMany(
    { vendorId },
    { 
      status: 'cancelled',
      cancelledAt: new Date()
    }
  )
}

export const deleteBookingsByVendor = async (vendorId: string) => {
  await connectToDatabase()
  await Booking.deleteMany({ providerId: vendorId })
}

export const deleteUserCartItemsByVendor = async (vendorId: string) => {
  await connectToDatabase()
  // Remove items from all user carts where the item belongs to this vendor
  await UserCart.updateMany(
    { 'items.vendorId': vendorId },
    { $pull: { items: { vendorId } } }
  )
}

export const deleteConversationsByVendor = async (vendorId: string) => {
  // ...messages feature removed for rebuild...
}

export const deleteUser = async (userId: string) => {
  await connectToDatabase()
  await User.findByIdAndDelete(userId)
}

export const deleteSessions = async (userId: string) => {
  await connectToDatabase()
  const { Session } = await import('./mongodb-auth')
  await Session.deleteMany({ userId })
}